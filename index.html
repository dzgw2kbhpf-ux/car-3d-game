<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>car-3d-game</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
*{
  -webkit-user-select:none;
  -webkit-touch-callout:none;
  user-select:none;
}
html,body{
  margin:0;
  padding:0;
  overflow:hidden;
}
#ui{
  position:fixed;
  top:10px;
  left:50%;
  transform:translateX(-50%);
  color:#fff;
  background:rgba(0,0,0,0.5);
  padding:8px 12px;
  border-radius:8px;
  font-family:sans-serif;
  z-index:10;
}
</style>
</head>
<body>
<div id="ui">右下：アクセル / 左下：ブレーキ / 下中央：クラクション</div>

<script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
<script>
document.addEventListener("contextmenu",e=>e.preventDefault());

/* ===== 基本 ===== */
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x87ceeb);

const camera=new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,4000);
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

// 昼ライト
scene.add(new THREE.HemisphereLight(0xffffff,0xcccccc,1.3));
const sun=new THREE.DirectionalLight(0xffffff,1);
sun.position.set(30,50,20);
scene.add(sun);

/* ===== 車 ===== */
const car=new THREE.Group();
scene.add(car);
const body=new THREE.Mesh(
  new THREE.BoxGeometry(1.8,0.6,3),
  new THREE.MeshStandardMaterial({color:0xff3333})
);
body.position.y=0.6;
car.add(body);

/* ===== 道路設定 ===== */
const CHUNK=50;
const VIEW=6;
const chunks=new Map();

const LANE_WIDTH=3.5;
const LANES_PER_SIDE=2;
const ROAD_WIDTH=LANE_WIDTH*LANES_PER_SIDE*2;
const SIDEWALK_WIDTH=3;
const BUILDING_OFFSET=4; // ← 建物を外側にずらした
const INTERSECTION_INTERVAL=4;

function createChunk(i){
  const g=new THREE.Group();
  const z=i*CHUNK;
  const isIntersection=(i%INTERSECTION_INTERVAL===0);

  // 道路
  const road=new THREE.Mesh(
    new THREE.PlaneGeometry(ROAD_WIDTH,CHUNK),
    new THREE.MeshStandardMaterial({color:0x222222})
  );
  road.rotation.x=-Math.PI/2;
  road.position.z=z+CHUNK/2;
  g.add(road);

  // センターライン（オレンジ実線）
  const centerLine=new THREE.Mesh(
    new THREE.PlaneGeometry(0.3,CHUNK),
    new THREE.MeshStandardMaterial({color:0xff9900})
  );
  centerLine.rotation.x=-Math.PI/2;
  centerLine.position.set(0,0.02,z+CHUNK/2);
  g.add(centerLine);

  // 車線境界（白破線）
  [-LANE_WIDTH,LANE_WIDTH].forEach(x=>{
    for(let l=0;l<5;l++){
      const line=new THREE.Mesh(
        new THREE.PlaneGeometry(0.2,4),
        new THREE.MeshStandardMaterial({color:0xffffff})
      );
      line.rotation.x=-Math.PI/2;
      line.position.set(x,0.02,z+l*10+5);
      g.add(line);
    }
  });

  // 歩道内側白破線
  [-1,1].forEach(side=>{
    for(let l=0;l<5;l++){
      const line=new THREE.Mesh(
        new THREE.PlaneGeometry(0.2,4),
        new THREE.MeshStandardMaterial({color:0xffffff})
      );
      line.rotation.x=-Math.PI/2;
      line.position.set(side*(ROAD_WIDTH/2-0.5),0.02,z+l*10+5);
      g.add(line);
    }
  });

  // 外側白線（白・実線）
  [-1,1].forEach(side=>{
    const edge=new THREE.Mesh(
      new THREE.PlaneGeometry(0.25,CHUNK),
      new THREE.MeshStandardMaterial({color:0xffffff})
    );
    edge.rotation.x=-Math.PI/2;
    edge.position.set(side*(ROAD_WIDTH/2+0.01),0.02,z+CHUNK/2);
    g.add(edge);
  });

  // 歩道
  [-1,1].forEach(side=>{
    const walk=new THREE.Mesh(
      new THREE.BoxGeometry(SIDEWALK_WIDTH,0.3,CHUNK),
      new THREE.MeshStandardMaterial({color:0x999999})
    );
    walk.position.set(side*(ROAD_WIDTH/2+SIDEWALK_WIDTH/2),0.15,z+CHUNK/2);
    g.add(walk);

    const walk2=new THREE.Mesh(
      new THREE.BoxGeometry(5,0.25,CHUNK),
      new THREE.MeshStandardMaterial({color:0xaaaaaa})
    );
    walk2.position.set(side*(ROAD_WIDTH/2+SIDEWALK_WIDTH+2.5),0.12,z+CHUNK/2);
    g.add(walk2);
  });

  // 建物（外側に寄せた）
  for(let b=0;b<3;b++){
    [-1,1].forEach(side=>{
      const h=12+Math.random()*10;
      const build=new THREE.Mesh(
        new THREE.BoxGeometry(8,h,10),
        new THREE.MeshStandardMaterial({color:0x888888})
      );
      build.position.set(
        side*(ROAD_WIDTH/2+SIDEWALK_WIDTH+BUILDING_OFFSET),
        h/2,
        z+10+b*15
      );
      g.add(build);
    });
  }

  scene.add(g);
  chunks.set(i,g);
}

function updateChunks(){
  const cur=Math.floor(car.position.z/CHUNK);
  for(let i=cur-VIEW;i<=cur+VIEW;i++){
    if(!chunks.has(i)) createChunk(i);
  }
  for(const [i,g] of chunks){
    if(Math.abs(i-cur)>VIEW){
      scene.remove(g);
      chunks.delete(i);
    }
  }
}

/* ===== ループ ===== */
let speed=0;
const MAX_SPEED=0.15;

camera.position.set(0,4,-10);

function animate(){
  requestAnimationFrame(animate);
  speed=MAX_SPEED*0.5;
  car.position.z+=speed*10;

  updateChunks();

  camera.position.z=car.position.z-10;
  camera.lookAt(0,1,car.position.z+15);

  renderer.render(scene,camera);
}
animate();

addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
