<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>car-3d-game</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
html,body{margin:0;padding:0;overflow:hidden}
</style>
</head>
<body>

<script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
<script>
/* ===== 基本 ===== */
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x87ceeb);

const camera=new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,4000);
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.HemisphereLight(0xffffff,0xcccccc,1.3));
scene.add(new THREE.DirectionalLight(0xffffff,1));

/* ===== 車 ===== */
const car=new THREE.Mesh(
  new THREE.BoxGeometry(1.8,0.6,3),
  new THREE.MeshStandardMaterial({color:0xff3333})
);
car.position.y=0.6;
scene.add(car);

/* ===== 定数 ===== */
const CHUNK=50;
const VIEW=6;
const LANE=3.5;
const ROAD_WIDTH=LANE*4;
const EDGE_GAP=0.3;
const SIDEWALK=3;
const BUILDING_OFFSET=5;
const INTERVAL=4;
const chunks=new Map();

/* ===== 直線道路（Z方向） ===== */
function straightZ(){
  const g=new THREE.Group();

  // 道
  const road=new THREE.Mesh(
    new THREE.PlaneGeometry(ROAD_WIDTH,CHUNK),
    new THREE.MeshStandardMaterial({color:0x222222})
  );
  road.rotation.x=-Math.PI/2;
  g.add(road);

  // センターライン
  const center=new THREE.Mesh(
    new THREE.PlaneGeometry(0.3,CHUNK),
    new THREE.MeshStandardMaterial({color:0xff9900})
  );
  center.rotation.x=-Math.PI/2;
  center.position.y=0.05;
  g.add(center);

  // 外側白線
  [-1,1].forEach(s=>{
    const edge=new THREE.Mesh(
      new THREE.PlaneGeometry(0.3,CHUNK),
      new THREE.MeshStandardMaterial({color:0xffffff})
    );
    edge.rotation.x=-Math.PI/2;
    edge.position.set(s*(ROAD_WIDTH/2-0.15),0.06,0);
    g.add(edge);
  });

  // 歩道
  [-1,1].forEach(s=>{
    const walk=new THREE.Mesh(
      new THREE.BoxGeometry(SIDEWALK,0.3,CHUNK),
      new THREE.MeshStandardMaterial({color:0x999999})
    );
    walk.position.set(
      s*(ROAD_WIDTH/2+EDGE_GAP+SIDEWALK/2),
      0.15,
      0
    );
    g.add(walk);
  });

  // 建物（Z方向に並ぶ）
  for(let i=0;i<3;i++){
    [-1,1].forEach(s=>{
      const h=12+Math.random()*10;
      const b=new THREE.Mesh(
        new THREE.BoxGeometry(8,h,10),
        new THREE.MeshStandardMaterial({color:0x888888})
      );
      b.position.set(
        s*(ROAD_WIDTH/2+EDGE_GAP+SIDEWALK+BUILDING_OFFSET),
        h/2,
        -CHUNK/2+10+i*15
      );
      g.add(b);
    });
  }

  return g;
}

/* ===== 横道（X方向専用） ===== */
function straightX(){
  const g=new THREE.Group();

  const road=new THREE.Mesh(
    new THREE.PlaneGeometry(CHUNK,ROAD_WIDTH),
    new THREE.MeshStandardMaterial({color:0x222222})
  );
  road.rotation.x=-Math.PI/2;
  g.add(road);

  // センターライン
  const center=new THREE.Mesh(
    new THREE.PlaneGeometry(CHUNK,0.3),
    new THREE.MeshStandardMaterial({color:0xff9900})
  );
  center.rotation.x=-Math.PI/2;
  center.position.y=0.05;
  g.add(center);

  // 外側白線
  [-1,1].forEach(s=>{
    const edge=new THREE.Mesh(
      new THREE.PlaneGeometry(CHUNK,0.3),
      new THREE.MeshStandardMaterial({color:0xffffff})
    );
    edge.rotation.x=-Math.PI/2;
    edge.position.set(0,0.06,s*(ROAD_WIDTH/2-0.15));
    g.add(edge);
  });

  // 歩道
  [-1,1].forEach(s=>{
    const walk=new THREE.Mesh(
      new THREE.BoxGeometry(CHUNK,0.3,SIDEWALK),
      new THREE.MeshStandardMaterial({color:0x999999})
    );
    walk.position.set(
      0,
      0.15,
      s*(ROAD_WIDTH/2+EDGE_GAP+SIDEWALK/2)
    );
    g.add(walk);
  });

  // 建物（X方向に並ぶ）
  for(let i=0;i<3;i++){
    [-1,1].forEach(s=>{
      const h=12+Math.random()*10;
      const b=new THREE.Mesh(
        new THREE.BoxGeometry(10,h,8),
        new THREE.MeshStandardMaterial({color:0x888888})
      );
      b.position.set(
        -CHUNK/2+10+i*15,
        h/2,
        s*(ROAD_WIDTH/2+EDGE_GAP+SIDEWALK+BUILDING_OFFSET)
      );
      g.add(b);
    });
  }

  return g;
}

/* ===== チャンク生成 ===== */
function createChunk(i){
  const g=new THREE.Group();
  const z=i*CHUNK+CHUNK/2;

  if(i%INTERVAL===0){
    const center=new THREE.Mesh(
      new THREE.PlaneGeometry(ROAD_WIDTH,CHUNK),
      new THREE.MeshStandardMaterial({color:0x222222})
    );
    center.rotation.x=-Math.PI/2;
    center.position.z=z;
    g.add(center);

    [-1,1].forEach(s=>{
      const side=straightX();
      side.position.set(
        s*(ROAD_WIDTH/2+CHUNK/2),
        0,
        z
      );
      g.add(side);
    });
  }else{
    const straight=straightZ();
    straight.position.z=z;
    g.add(straight);
  }

  scene.add(g);
  chunks.set(i,g);
}

function update(){
  const cur=Math.floor(car.position.z/CHUNK);
  for(let i=cur-VIEW;i<=cur+VIEW;i++){
    if(!chunks.has(i)) createChunk(i);
  }
}

/* ===== ループ ===== */
camera.position.set(0,5,-12);
function animate(){
  requestAnimationFrame(animate);
  car.position.z+=1;
  update();
  camera.position.z=car.position.z-12;
  camera.lookAt(0,1,car.position.z+20);
  renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>
