<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>car-3d-game</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
*{user-select:none}
html,body{margin:0;padding:0;overflow:hidden}
</style>
</head>
<body>

<script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
<script>
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x87ceeb);

const camera=new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,4000);
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.HemisphereLight(0xffffff,0xcccccc,1.3));
const sun=new THREE.DirectionalLight(0xffffff,1);
sun.position.set(30,50,20);
scene.add(sun);

/* 車 */
const car=new THREE.Group();
scene.add(car);
const body=new THREE.Mesh(
  new THREE.BoxGeometry(1.8,0.6,3),
  new THREE.MeshStandardMaterial({color:0xff3333})
);
body.position.y=0.6;
car.add(body);

/* 定数 */
const CHUNK=50;
const VIEW=6;
const LANE_WIDTH=3.5;
const ROAD_WIDTH=LANE_WIDTH*2*2;
const INTERVAL=5;
const chunks=new Map();

/* 直線道路 */
function straight(z){
  const g=new THREE.Group();

  const road=new THREE.Mesh(
    new THREE.PlaneGeometry(ROAD_WIDTH,CHUNK),
    new THREE.MeshStandardMaterial({color:0x222222})
  );
  road.rotation.x=-Math.PI/2;
  road.position.z=z;
  g.add(road);

  const center=new THREE.Mesh(
    new THREE.PlaneGeometry(0.3,CHUNK),
    new THREE.MeshStandardMaterial({color:0xff9900})
  );
  center.rotation.x=-Math.PI/2;
  center.position.set(0,0.05,z);
  g.add(center);

  scene.add(g);
}

/* チャンク生成 */
function createChunk(i){
  const z=i*CHUNK+CHUNK/2;
  const isCross=i%INTERVAL===0;

  const g=new THREE.Group();

  if(isCross){
    /* 中央（線なし） */
    const centerRoad=new THREE.Mesh(
      new THREE.PlaneGeometry(ROAD_WIDTH,CHUNK),
      new THREE.MeshStandardMaterial({color:0x222222})
    );
    centerRoad.rotation.x=-Math.PI/2;
    centerRoad.position.z=z;
    g.add(centerRoad);

    /* 横道（前にずらすのが超重要） */
    [-1,1].forEach(side=>{
      const sideRoad=new THREE.Mesh(
        new THREE.PlaneGeometry(ROAD_WIDTH,CHUNK),
        new THREE.MeshStandardMaterial({color:0x222222})
      );
      sideRoad.rotation.x=-Math.PI/2;
      sideRoad.rotation.z=Math.PI/2;
      sideRoad.position.set(
        side*(ROAD_WIDTH/2),
        0.01,
        z+15   // ← ここが「見える魔法」
      );
      g.add(sideRoad);
    });

  }else{
    const road=new THREE.Mesh(
      new THREE.PlaneGeometry(ROAD_WIDTH,CHUNK),
      new THREE.MeshStandardMaterial({color:0x222222})
    );
    road.rotation.x=-Math.PI/2;
    road.position.z=z;
    g.add(road);
  }

  scene.add(g);
  chunks.set(i,g);
}

function update(){
  const cur=Math.floor(car.position.z/CHUNK);
  for(let i=cur-VIEW;i<=cur+VIEW;i++){
    if(!chunks.has(i)) createChunk(i);
  }
}

camera.position.set(0,4,-10);

function animate(){
  requestAnimationFrame(animate);
  car.position.z+=0.8;
  update();
  camera.position.z=car.position.z-10;
  camera.lookAt(0,1,car.position.z+15);
  renderer.render(scene,camera);
}
animate();

addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
