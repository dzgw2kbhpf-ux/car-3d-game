<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>car-3d-game</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
html,body{margin:0;padding:0;overflow:hidden}
</style>
</head>
<body>

<script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
<script>
/* ===== 基本 ===== */
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x87ceeb);

const camera=new THREE.PerspectiveCamera(60,innerWidth/innerHeight,0.1,5000);
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

scene.add(new THREE.HemisphereLight(0xffffff,0xcccccc,1.3));
scene.add(new THREE.DirectionalLight(0xffffff,1));

/* ===== 車 ===== */
const car=new THREE.Mesh(
  new THREE.BoxGeometry(1.8,0.6,3),
  new THREE.MeshStandardMaterial({color:0xff3333})
);
car.position.y=0.6;
scene.add(car);

/* ===== 定数 ===== */
const CHUNK=50;
const VIEW=6;
const LANE=3.5;
const ROAD_WIDTH=LANE*4;
const SIDEWALK=3;
const WALK_H=0.3;
const BUILDING_OFFSET=5;
const INTERVAL=4;
const GROUND_Y=-0.02;
const EXTEND=SIDEWALK*6;
const GAP=0.25;
const chunks=new Map();

/* ===== 歩道タイル ===== */
function sidewalkTexture(){
  const c=document.createElement("canvas");
  c.width=c.height=512;
  const ctx=c.getContext("2d");
  ctx.fillStyle="#555";
  ctx.fillRect(0,0,512,512);
  for(let i=0;i<220;i++){
    const s=[16,24,32,40][Math.floor(Math.random()*4)];
    const x=Math.random()*(512-s);
    const y=Math.random()*(512-s);
    const g=90+Math.random()*30;
    ctx.fillStyle=`rgb(${g},${g},${g})`;
    ctx.fillRect(x,y,s,s);
  }
  const t=new THREE.CanvasTexture(c);
  t.wrapS=t.wrapT=THREE.RepeatWrapping;
  t.repeat.set(3,3);
  return t;
}
const sidewalkMat=new THREE.MeshStandardMaterial({map:sidewalkTexture()});

/* ===== 地面 ===== */
function addGround(g,w,d){
  const m=new THREE.Mesh(
    new THREE.PlaneGeometry(w,d),
    sidewalkMat
  );
  m.rotation.x=-Math.PI/2;
  m.position.y=GROUND_Y;
  g.add(m);
}

/* ===== 建物（4面すべて同一窓） ===== */
function addBuilding(x,z,w,d,g){
  const h=18+Math.random()*6;

  const body=new THREE.Mesh(
    new THREE.BoxGeometry(w,h,d),
    new THREE.MeshStandardMaterial({color:0xffffff})
  );
  body.position.set(x,h/2,z);
  g.add(body);

  const winMat=new THREE.MeshStandardMaterial({
    color:0xaad7ff,
    emissive:0x335577,
    emissiveIntensity:0.6
  });

  const floorH=3;

  for(let y=floorH*1.3;y<h-2;y+=floorH){

    // 左右
    for(let wz=-d/2+1.2;wz<d/2-1.2;wz+=2){
      const wl=new THREE.Mesh(
        new THREE.PlaneGeometry(1.2,1.4),
        winMat
      );
      wl.rotation.y=Math.PI/2;
      wl.position.set(x-w/2-0.05,y,z+wz);
      g.add(wl);

      const wr=wl.clone();
      wr.rotation.y=-Math.PI/2;
      wr.position.set(x+w/2+0.05,y,z+wz);
      g.add(wr);
    }

    // 前後（左右と同じサイズ・間隔）
    for(let wx=-w/2+1.2;wx<w/2-1.2;wx+=2){
      const wf=new THREE.Mesh(
        new THREE.PlaneGeometry(1.2,1.4),
        winMat
      );
      wf.position.set(x+wx,y,z+d/2+0.05);
      g.add(wf);

      const wb=wf.clone();
      wb.rotation.y=Math.PI;
      wb.position.set(x+wx,y,z-d/2-0.05);
      g.add(wb);
    }
  }
}

/* ===== 建物配置 ===== */
function addBuildingsZ(g){
  for(let i=0;i<3;i++){
    [-1,1].forEach(s=>{
      addBuilding(
        s*(ROAD_WIDTH/2+SIDEWALK+BUILDING_OFFSET),
        -CHUNK/2+10+i*15,
        8,10,g
      );
    });
  }
}
function addBuildingsX(g){
  for(let i=0;i<3;i++){
    [-1,1].forEach(s=>{
      addBuilding(
        -CHUNK/2+10+i*15,
        s*(ROAD_WIDTH/2+SIDEWALK+BUILDING_OFFSET),
        10,8,g
      );
    });
  }
}

/* ===== 白線 ===== */
function edgeLineZ(g){
  [-1,1].forEach(s=>{
    const e=new THREE.Mesh(
      new THREE.PlaneGeometry(0.3,CHUNK),
      new THREE.MeshStandardMaterial({color:0xffffff})
    );
    e.rotation.x=-Math.PI/2;
    e.position.set(s*(ROAD_WIDTH/2-0.15-GAP),0.06,0);
    g.add(e);
  });
}

/* ===== 破線 ===== */
function addDashesZ(g){
  [-LANE,LANE].forEach(x=>{
    for(let i=0;i<5;i++){
      const d=new THREE.Mesh(
        new THREE.PlaneGeometry(0.2,4),
        new THREE.MeshStandardMaterial({color:0xffffff})
      );
      d.rotation.x=-Math.PI/2;
      d.position.set(x,0.05,-CHUNK/2+5+i*10);
      g.add(d);
    }
  });
}

/* ===== 直線Z ===== */
function straightZ(){
  const g=new THREE.Group();
  addGround(g,ROAD_WIDTH+SIDEWALK*2+20,CHUNK+EXTEND*2+20);

  const road=new THREE.Mesh(
    new THREE.PlaneGeometry(ROAD_WIDTH,CHUNK),
    new THREE.MeshStandardMaterial({color:0x222222})
  );
  road.rotation.x=-Math.PI/2;
  g.add(road);

  const center=new THREE.Mesh(
    new THREE.PlaneGeometry(0.3,CHUNK),
    new THREE.MeshStandardMaterial({color:0xff9900})
  );
  center.rotation.x=-Math.PI/2;
  center.position.y=0.05;
  g.add(center);

  addDashesZ(g);
  edgeLineZ(g);

  [-1,1].forEach(s=>{
    const w=new THREE.Mesh(
      new THREE.BoxGeometry(SIDEWALK,WALK_H,CHUNK+EXTEND*2),
      sidewalkMat
    );
    w.position.set(
      s*(ROAD_WIDTH/2+SIDEWALK/2+GAP),
      WALK_H/2,
      0
    );
    g.add(w);
  });

  addBuildingsZ(g);
  return g;
}

/* ===== 横道X ===== */
function straightX(){
  const g=new THREE.Group();
  addGround(g,CHUNK+20,ROAD_WIDTH+SIDEWALK*2+20);

  const road=new THREE.Mesh(
    new THREE.PlaneGeometry(CHUNK,ROAD_WIDTH),
    new THREE.MeshStandardMaterial({color:0x222222})
  );
  road.rotation.x=-Math.PI/2;
  g.add(road);

  [-1,1].forEach(s=>{
    const w=new THREE.Mesh(
      new THREE.BoxGeometry(CHUNK,WALK_H,SIDEWALK),
      sidewalkMat
    );
    w.position.set(
      0,
      WALK_H/2,
      s*(ROAD_WIDTH/2+SIDEWALK/2+GAP)
    );
    g.add(w);
  });

  addBuildingsX(g);
  return g;
}

/* ===== 交差点 ===== */
function intersection(){
  const g=new THREE.Group();
  addGround(g,ROAD_WIDTH+SIDEWALK*2+20,CHUNK+20);

  const road=new THREE.Mesh(
    new THREE.PlaneGeometry(ROAD_WIDTH,CHUNK),
    new THREE.MeshStandardMaterial({color:0x222222})
  );
  road.rotation.x=-Math.PI/2;
  g.add(road);
  return g;
}

/* ===== チャンク ===== */
function createChunk(i){
  const g=new THREE.Group();
  const z=i*CHUNK+CHUNK/2;

  if(i%INTERVAL===0){
    const c=intersection();
    c.position.z=z;
    g.add(c);

    [-1,1].forEach(s=>{
      const x=straightX();
      x.position.set(s*(ROAD_WIDTH/2+CHUNK/2),0,z);
      g.add(x);
    });
  }else{
    const s=straightZ();
    s.position.z=z;
    g.add(s);
  }

  scene.add(g);
  chunks.set(i,g);
}

/* ===== ループ ===== */
function update(){
  const cur=Math.floor(car.position.z/CHUNK);
  for(let i=cur-VIEW;i<=cur+VIEW;i++){
    if(!chunks.has(i)) createChunk(i);
  }
}

camera.position.set(0,5,-12);
function animate(){
  requestAnimationFrame(animate);
  car.position.z+=1;
  update();
  camera.position.z=car.position.z-12;
  camera.lookAt(0,1,car.position.z+20);
  renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>
