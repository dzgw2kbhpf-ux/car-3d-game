<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>car-3d-game</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<style>
body { margin:0; overflow:hidden; }
#ui{
  position:fixed;
  top:10px;
  left:50%;
  transform:translateX(-50%);
  color:#fff;
  background:rgba(0,0,0,0.5);
  padding:8px 12px;
  border-radius:8px;
  font-family:sans-serif;
  z-index:10;
}
</style>
</head>
<body>
<div id="ui">右下：アクセル / 左下：ブレーキ / 下中央：クラクション</div>

<script src="https://unpkg.com/three@0.155.0/build/three.min.js"></script>
<script>
/* ===== 基本 ===== */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87ceeb);

const camera = new THREE.PerspectiveCamera(60, innerWidth/innerHeight, 0.1, 5000);
const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
document.body.appendChild(renderer.domElement);

// 昼固定ライト
scene.add(new THREE.HemisphereLight(0xffffff,0xcccccc,1.3));
const sun = new THREE.DirectionalLight(0xffffff,1);
sun.position.set(20,40,10);
scene.add(sun);

/* ===== 音 ===== */
let audioCtx, engineOsc, engineGain;
function initAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext||window.webkitAudioContext)();
  engineOsc = audioCtx.createOscillator();
  engineGain = audioCtx.createGain();
  engineOsc.type = "sawtooth";
  engineOsc.frequency.value = 60;
  engineGain.gain.value = 0.08;
  engineOsc.connect(engineGain);
  engineGain.connect(audioCtx.destination);
  engineOsc.start();
}
function horn(){
  if(!audioCtx) return;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type="square"; o.frequency.value=400;
  g.gain.value=0.25;
  o.connect(g); g.connect(audioCtx.destination);
  o.start(); o.stop(audioCtx.currentTime+0.15);
}

/* ===== 車 ===== */
const car = new THREE.Group();
scene.add(car);
const body = new THREE.Mesh(
  new THREE.BoxGeometry(1.8,0.6,3),
  new THREE.MeshStandardMaterial({color:0xff3333})
);
body.position.y=0.6;
car.add(body);

/* ===== 操作 ===== */
let accel=false, brake=false;
let speed=0;
const MAX_SPEED=0.15;   // ← 速度は半分
const ACCEL=0.003;
const BRAKE=0.006;

function inputStart(e){
  initAudio();
  const x = e.touches?e.touches[0].clientX:e.clientX;
  const y = e.touches?e.touches[0].clientY:e.clientY;

  if(y > innerHeight*0.75 && x>innerWidth*0.33 && x<innerWidth*0.66){
    horn(); return;
  }
  if(y > innerHeight*0.75){
    accel = x > innerWidth/2;
    brake = x <= innerWidth/2;
  }
}
function inputEnd(){ accel=false; brake=false; }

addEventListener("touchstart",inputStart);
addEventListener("touchend",inputEnd);
addEventListener("mousedown",inputStart);
addEventListener("mouseup",inputEnd);

/* ===== 無限カーブ道路（完全安定版） ===== */
const CHUNK=50;
const VIEW=5;
const chunks=new Map();
let carDist=0;

function createChunk(i){
  const g=new THREE.Group();

  const prev=chunks.get(i-1);
  const startX=prev?prev.userData.endX:0;
  const startZ=prev?prev.userData.endZ:0;
  const baseAngle=prev?prev.userData.angle:0;

  const angle=baseAngle+(Math.random()-0.5)*0.25;
  const dirX=Math.sin(angle);
  const dirZ=Math.cos(angle);

  const endX=startX+dirX*CHUNK;
  const endZ=startZ+dirZ*CHUNK;

  g.userData={angle,dirX,dirZ,startX,startZ,endX,endZ};

  // 道路
  const road=new THREE.Mesh(
    new THREE.PlaneGeometry(20,CHUNK),
    new THREE.MeshStandardMaterial({color:0x222222})
  );
  road.rotation.x=-Math.PI/2;
  road.rotation.z=angle;
  road.position.set((startX+endX)/2,0,(startZ+endZ)/2);
  g.add(road);

  // 建物
  for(let i2=0;i2<6;i2++){
    const h=3+Math.random()*10;
    const b=new THREE.Mesh(
      new THREE.BoxGeometry(2+Math.random()*3,h,2+Math.random()*3),
      new THREE.MeshStandardMaterial({color:0x888888})
    );
    const side=Math.random()>0.5?1:-1;
    b.position.set(
      (startX+endX)/2+side*(7+Math.random()*5),
      h/2,
      (startZ+endZ)/2+(Math.random()-0.5)*CHUNK
    );
    g.add(b);
  }

  scene.add(g);
  chunks.set(i,g);
}

function updateChunks(){
  const cur=Math.floor(carDist/CHUNK);
  for(let i=cur-VIEW;i<=cur+VIEW;i++){
    if(!chunks.has(i)) createChunk(i);
  }
  for(const [i,g] of chunks){
    if(Math.abs(i-cur)>VIEW){
      scene.remove(g);
      chunks.delete(i);
    }
  }
}

/* ===== ループ ===== */
camera.position.set(0,4,-8);

function animate(){
  requestAnimationFrame(animate);

  if(accel) speed+=ACCEL;
  if(brake) speed-=BRAKE;
  speed*=0.98;
  speed=Math.max(0,Math.min(MAX_SPEED,speed));

  carDist+=speed*10;
  const cur=Math.floor(carDist/CHUNK);
  const g=chunks.get(cur);

  if(g){
    car.rotation.y=g.userData.angle;
    car.position.x=g.userData.startX+g.userData.dirX*(carDist-cur*CHUNK);
    car.position.z=g.userData.startZ+g.userData.dirZ*(carDist-cur*CHUNK);
  }

  if(engineOsc) engineOsc.frequency.value=60+speed*600;

  updateChunks();

  camera.position.x=car.position.x-Math.sin(car.rotation.y)*8;
  camera.position.z=car.position.z-Math.cos(car.rotation.y)*8;
  camera.lookAt(car.position.x,1,car.position.z);

  renderer.render(scene,camera);
}
animate();

addEventListener("resize",()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});
</script>
</body>
</html>
